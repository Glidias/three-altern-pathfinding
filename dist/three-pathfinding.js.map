{"version":3,"file":"three-pathfinding.js","sources":["../src/Utils.js","../src/BinaryHeap.js","../src/AStar.js","../src/Builder.js","../src/Channel.js","../src/index.js"],"sourcesContent":["class Utils {\n\n  static computeCentroids (geometry) {\n    var f, fl, face;\n\n    for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n      face = geometry.faces[ f ];\n      face.centroid = new Utils.Vec3Constructor( 0, 0, 0 );\n\n      face.centroid.add( geometry.vertices[ face.a ] );\n      face.centroid.add( geometry.vertices[ face.b ] );\n      face.centroid.add( geometry.vertices[ face.c ] );\n      face.centroid.divideScalar( 3 );\n\n    }\n  }\n\n  static roundNumber (value, decimals) {\n    return Number(value.toFixed(decimals));\n  }\n\n  static sample (list) {\n    return list[Math.floor(Math.random() * list.length)];\n  }\n\n  static mergeVertexIds (aList, bList) {\n\n    var sharedVertices = [];\n\n    aList.forEach((vID) => {\n      if (bList.indexOf(vID) >= 0) {\n        sharedVertices.push(vID);\n      }\n    });\n\n    if (sharedVertices.length < 2) return [];\n\n    if (sharedVertices.includes(aList[0]) && sharedVertices.includes(aList[aList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      aList.push(aList.shift());\n    }\n\n    if (sharedVertices.includes(bList[0]) && sharedVertices.includes(bList[bList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      bList.push(bList.shift());\n    }\n\n    // Again!\n    sharedVertices = [];\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVertices.push(vId);\n      }\n    });\n\n    var clockwiseMostSharedVertex = sharedVertices[1];\n    var counterClockwiseMostSharedVertex = sharedVertices[0];\n\n\n    var cList = aList.slice();\n    while (cList[0] !== clockwiseMostSharedVertex) {\n      cList.push(cList.shift());\n    }\n\n    var c = 0;\n\n    var temp = bList.slice();\n    while (temp[0] !== counterClockwiseMostSharedVertex) {\n      temp.push(temp.shift());\n\n      if (c++ > 10) throw new Error('Unexpected state');\n    }\n\n    // Shave\n    temp.shift();\n    temp.pop();\n\n    cList = cList.concat(temp);\n\n    return cList;\n  }\n\n  static setPolygonCentroid (polygon, navigationMesh) {\n    var sum = new Utils.Vec3Constructor;\n\n    var vertices = navigationMesh.vertices;\n\n    polygon.vertexIds.forEach((vId) => {\n      sum.add(vertices[vId]);\n    });\n\n    sum.divideScalar(polygon.vertexIds.length);\n\n    polygon.centroid.copy(sum);\n  }\n\n  static cleanPolygon (polygon, navigationMesh) {\n\n    var newVertexIds = [];\n\n    var vertices = navigationMesh.vertices;\n\n    for (var i = 0; i < polygon.vertexIds.length; i++) {\n\n      var vertex = vertices[polygon.vertexIds[i]];\n\n      var nextVertexId, previousVertexId;\n      var nextVertex, previousVertex;\n\n      if (i === 0) {\n        nextVertexId = polygon.vertexIds[1];\n        previousVertexId = polygon.vertexIds[polygon.vertexIds.length - 1];\n      } else if (i === polygon.vertexIds.length - 1) {\n        nextVertexId = polygon.vertexIds[0];\n        previousVertexId = polygon.vertexIds[polygon.vertexIds.length - 2];\n      } else {\n        nextVertexId = polygon.vertexIds[i + 1];\n        previousVertexId = polygon.vertexIds[i - 1];\n      }\n\n      nextVertex = vertices[nextVertexId];\n      previousVertex = vertices[previousVertexId];\n\n      var a = nextVertex.clone().sub(vertex);\n      var b = previousVertex.clone().sub(vertex);\n\n      var angle = a.angleTo(b);\n\n      if (angle > Math.PI - 0.01 && angle < Math.PI + 0.01) {\n\n        // Remove the neighbours who had this vertex\n        var goodNeighbours = [];\n        polygon.neighbours.forEach((neighbour) => {\n          if (!neighbour.vertexIds.includes(polygon.vertexIds[i])) {\n            goodNeighbours.push(neighbour);\n          }\n        });\n        polygon.neighbours = goodNeighbours;\n\n\n        // TODO cleanup the list of vertices and rebuild vertexIds for all polygons\n      } else {\n        newVertexIds.push(polygon.vertexIds[i]);\n      }\n\n    }\n\n    polygon.vertexIds = newVertexIds;\n\n    this.setPolygonCentroid(polygon, navigationMesh);\n\n  }\n\n  static isConvex (polygon, navigationMesh) {\n\n    var vertices = navigationMesh.vertices;\n\n    if (polygon.vertexIds.length < 3) return false;\n\n    var convex = true;\n\n    var total = 0;\n\n    var results = [];\n\n    for (var i = 0; i < polygon.vertexIds.length; i++) {\n\n      var vertex = vertices[polygon.vertexIds[i]];\n\n      var nextVertex, previousVertex;\n\n      if (i === 0) {\n        nextVertex = vertices[polygon.vertexIds[1]];\n        previousVertex = vertices[polygon.vertexIds[polygon.vertexIds.length - 1]];\n      } else if (i === polygon.vertexIds.length - 1) {\n        nextVertex = vertices[polygon.vertexIds[0]];\n        previousVertex = vertices[polygon.vertexIds[polygon.vertexIds.length - 2]];\n      } else {\n        nextVertex = vertices[polygon.vertexIds[i + 1]];\n        previousVertex = vertices[polygon.vertexIds[i - 1]];\n      }\n\n      var a = nextVertex.clone().sub(vertex);\n      var b = previousVertex.clone().sub(vertex);\n\n      var angle = a.angleTo(b);\n      total += angle;\n\n      if (angle === Math.PI || angle === 0) return false;\n\n      var r = a.cross(b).y;\n      results.push(r);\n    }\n\n    // if ( total > (polygon.vertexIds.length-2)*Math.PI ) return false;\n\n    results.forEach((r) => {\n      if (r === 0) convex = false;\n    });\n\n    if (results[0] > 0) {\n      results.forEach((r) => {\n        if (r < 0) convex = false;\n      });\n    } else {\n      results.forEach((r) => {\n        if (r > 0) convex = false;\n      });\n    }\n\n    return convex;\n  }\n\n  static distanceToSquared (a, b) {\n\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    var dz = a.z - b.z;\n\n    return dx * dx + dy * dy + dz * dz;\n\n  }\n\n  //+ Jonas Raoni Soares Silva\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\n  static isPointInPoly (poly, pt) {\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\n    return c;\n  }\n\n  static isVectorInPolygon (vector, polygon, vertices) {\n\n    // reference point will be the centroid of the polygon\n    // We need to rotate the vector as well as all the points which the polygon uses\n\n    var lowestPoint = 100000;\n    var highestPoint = -100000;\n\n    var polygonVertices = [];\n\n    polygon.vertexIds.forEach((vId) => {\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\n      polygonVertices.push(vertices[vId]);\n    });\n\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\n      this.isPointInPoly(polygonVertices, vector)) {\n      return true;\n    }\n    return false;\n  }\n\n  static triarea2 (a, b, c) {\n    var ax = b.x - a.x;\n    var az = b.z - a.z;\n    var bx = c.x - a.x;\n    var bz = c.z - a.z;\n    return bx * az - ax * bz;\n  }\n\n  static vequal (a, b) {\n    return this.distanceToSquared(a, b) < 0.00001;\n  }\n}\nUtils.Vec3Constructor = window.THREE ? THREE.Vector3 : null;\n\nexport { Utils };\n","// javascript-astar\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a binary heap.\n\nclass BinaryHeap {\n  constructor (scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop () {\n    // Store the first element so we can return it later.\n    const result = this.content[0];\n    // Get the element at the end of the array.\n    const end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n\n  remove (node) {\n    const i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    const end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size () {\n    return this.content.length;\n  }\n\n  rescoreElement (node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown (n) {\n    // Fetch the element that has to be sunk.\n    const element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      const parentN = ((n + 1) >> 1) - 1;\n      const parent = this.content[parentN];\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        // Swap the elements if the parent is greater.\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to sink any further.\n        break;\n      }\n    }\n  }\n\n  bubbleUp (n) {\n    // Look up the target element and its score.\n    const length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      const child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      let swap = null;\n      let child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        const child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        const child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n\n}\n\nexport { BinaryHeap };\n","import { BinaryHeap } from './BinaryHeap';\nimport { Utils } from './Utils.js';\n\nclass AStar {\n  static init (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      //for(var x in graph) {\n      const node = graph[x];\n      node.f = 0;\n      node.g = 0;\n      node.h = 0;\n      node.cost = 1.0;\n      node.visited = false;\n      node.closed = false;\n      node.parent = null;\n    }\n  }\n\n  static cleanUp (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      const node = graph[x];\n      delete node.f;\n      delete node.g;\n      delete node.h;\n      delete node.cost;\n      delete node.visited;\n      delete node.closed;\n      delete node.parent;\n    }\n  }\n\n  static heap () {\n    return new BinaryHeap(function (node) {\n      return node.f;\n    });\n  }\n\n  static search (graph, start, end) {\n    this.init(graph);\n    //heuristic = heuristic || astar.manhattan;\n\n\n    const openHeap = this.heap();\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      const currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        let curr = currentNode;\n        const ret = [];\n        while (curr.parent) {\n          ret.push(curr);\n          curr = curr.parent;\n        }\n        this.cleanUp(ret);\n        return ret.reverse();\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\n      currentNode.closed = true;\n\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\n      const neighbours = this.neighbours(graph, currentNode);\n\n      for (let i = 0, il = neighbours.length; i < il; i++) {\n        const neighbour = neighbours[i];\n\n        if (neighbour.closed) {\n          // Not a valid node to process, skip to next neighbour.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\n        const gScore = currentNode.g + (currentNode.neighbourCosts ? currentNode.neighbourCosts[i] : neighbour.cost);  // currentNode.neighbourCosts ? currentNode.neighbourCosts[i] :\n        const beenVisited = neighbour.visited;\n\n        if (!beenVisited || gScore < neighbour.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbour.visited = true;\n          neighbour.parent = currentNode;\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\n          neighbour.g = gScore;\n          neighbour.f = neighbour.g + neighbour.h;\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbour);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbour);\n          }\n        }\n      }\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  }\n\n  static heuristic (pos1, pos2) {\n    var deltaX = pos2.x - pos1.x;\n    var deltaY = pos2.y - pos1.y;\n    var deltaZ = pos2.z - pos1.z;\n    // this one is overestimated.. //Utils.distanceToSquared(pos1, pos2);\n    return 2.5 * Math.sqrt(deltaX*deltaX + deltaY*deltaY +deltaZ*deltaZ);  //\n  }\n\n  static neighbours (graph, node) {\n    const ret = [];\n\n    for (let e = 0; e < node.neighbours.length; e++) {\n      ret.push(graph[node.neighbours[e]]);\n    }\n\n    return ret;\n  }\n}\n\nexport { AStar };\n","import { Utils } from './Utils';\n\nlet polygonId = 1;\n\nclass Builder {\n  /**\n   * Constructs groups from the given navigation mesh.\n   * @param  {THREE.Geometry} geometry\n   * @return {Zone}\n   */\n  static buildZone (geometry) {\n\n    const navMesh = this._buildNavigationMesh(geometry);\n\n    const zone = {};\n\n    navMesh.vertices.forEach((v) => {\n      v.x = Utils.roundNumber(v.x, 2);\n      v.y = Utils.roundNumber(v.y, 2);\n      v.z = Utils.roundNumber(v.z, 2);\n    });\n\n    zone.vertices = navMesh.vertices;\n\n    const groups = this._buildPolygonGroups(navMesh);\n\n    zone.groups = [];\n\n    const findPolygonIndex = function (group, p) {\n      for (let i = 0; i < group.length; i++) {\n        if (p === group[i]) return i;\n      }\n    };\n\n    // TODO: This block represents 50-60% of navigation mesh construction time,\n    // and could probably be optimized. For example, construct portals while\n    // determining the neighbor graph.\n    groups.forEach((group) => {\n\n      const newGroup = [];\n\n      group.forEach((p) => {\n\n        // TODO: Optimize.\n        const neighbours = p.neighbours.map((n) => findPolygonIndex(group, n));\n\n        // Build a portal list to each neighbour\n        const portals = p.neighbours.map((n) => this._getSharedVerticesInOrder(p, n));\n\n        p.centroid.x = Utils.roundNumber(p.centroid.x, 2);\n        p.centroid.y = Utils.roundNumber(p.centroid.y, 2);\n        p.centroid.z = Utils.roundNumber(p.centroid.z, 2);\n\n        newGroup.push({\n          id: findPolygonIndex(group, p),\n          neighbours: neighbours,\n          neighbourCosts: p.neighbourCosts,\n          vertexIds: p.vertexIds,\n          centroid: p.centroid,\n          portals: portals\n        });\n\n      });\n\n      zone.groups.push(newGroup);\n    });\n\n    return zone;\n  }\n\n  /**\n   * Constructs a navigation mesh from the given geometry.\n   * @param {THREE.Geometry} geometry\n   * @return {Object}\n   */\n  static _buildNavigationMesh (geometry) {\n    if (geometry.faces) Utils.computeCentroids(geometry);\n    if (geometry.mergeVertices) geometry.mergeVertices();\n    return this._buildPolygonsFromGeometry(geometry);\n  }\n\n  static _buildPolygonGroups (navigationMesh) {\n\n    const polygons = navigationMesh.polygons;\n\n    const polygonGroups = [];\n    let groupCount = 0;\n\n    const spreadGroupId = function (polygon) {\n      polygon.neighbours.forEach((neighbour) => {\n        if (neighbour.group === undefined) {\n          neighbour.group = polygon.group;\n          spreadGroupId(neighbour);\n        }\n      });\n    };\n\n    polygons.forEach((polygon) => {\n\n      if (polygon.group === undefined) {\n        polygon.group = groupCount++;\n        // Spread it\n        spreadGroupId(polygon);\n      }\n\n      if (!polygonGroups[polygon.group]) polygonGroups[polygon.group] = [];\n\n      polygonGroups[polygon.group].push(polygon);\n    });\n\n    return polygonGroups;\n  }\n\n  static _buildPolygonNeighbours (polygon, navigationMesh, vertexPolygonMap) {\n    const neighbors = new Set();\n\n    const groupA = vertexPolygonMap.get(polygon.vertexIds[0]);\n    const groupB = vertexPolygonMap.get(polygon.vertexIds[1]);\n    const groupC = vertexPolygonMap.get(polygon.vertexIds[2]);\n\n    // It's only necessary to iterate groups A and B. Polygons contained only\n    // in group C cannot share a >1 vertex with this polygon.\n    // IMPORTANT: Bublé cannot compile for-of loops.\n    groupA.forEach((candidate) => {\n      if (groupB.has(candidate) || groupC.has(candidate)) {\n        neighbors.add(navigationMesh.polygons[candidate]);\n      }\n    });\n    groupB.forEach((candidate) => {\n      if (groupC.has(candidate)) {\n        neighbors.add(navigationMesh.polygons[candidate]);\n      }\n    });\n\n    polygon.neighbours = Array.from(neighbors);\n    polygon.neighbourCosts = this._getCostsOfNeighboursFromCentroid(polygon.neighbours, polygon.centroid);\n  }\n\n  static _getCostsOfNeighboursFromCentroid (neighbors, centroid) {\n    return neighbors.map((n) => {\n      var dx = n.centroid.x - centroid.x;\n      var dy = n.centroid.y - centroid.y;\n      var dz = n.centroid.z - centroid.z;\n      return Math.sqrt(dx*dx + dy*dy + dz*dz);\n    });\n  }\n\n  static _alternCentroidFromVerticesIndices(vertices, a, b, c) {\n    a *=3;\n    b *=3;\n    c *=3;\n    var ax = vertices[a]; var ay = vertices[a+1]; var az = vertices[a+2];\n    var bx = vertices[b]; var by = vertices[b+1]; var bz = vertices[b+2];\n    var cx = vertices[c]; var cy = vertices[c+1]; var cz = vertices[c+2];\n    a = ax + bx + cx;\n    b = ay + by + cy;\n    c = az + bz + cz;\n    return new Utils.Vec3Constructor(a/3,b/3,c/3);\n  }\n\n  /*\n  static _alternNormalFromVerticesIndices(vertices, a, b, c) {\n    a *=3;\n    b *=3;\n    c *=3;\n    var ax = vertices[a]; var ay = vertices[a+1]; var az = vertices[a+2];\n    var bx = vertices[b]; var by = vertices[b+1]; var bz = vertices[b+2];\n    var cx = vertices[c]; var cy = vertices[c+1]; var cz = vertices[c+2];\n    var abx = bx - ax;\n    var aby = by - ay;\n    var abz = bz - az;\n    var acx = cx - ax;\n    var acy = cy - ay;\n    var acz = cz - az;\n    var normalX = acz*aby - acy*abz;\n    var normalY = acx*abz - acz*abx;\n    var normalZ = acy*abx - acx*aby;\n    var len = normalX*normalX + normalY*normalY + normalZ*normalZ;\n    if (len == 0) {\n      console.warn('_alternNormalFromVerticesIndices:: Zero length normal detected!'+ [normalX, normalY, normalZ]);\n      normalX = 0;\n      normalY = 1;\n      normalZ = 0;\n      len = 1;\n    }\n    len = 1/Math.sqrt(len);\n    normalX *= len;\n    normalY *= len;\n    normalZ *= len;\n    var offset = ax*normalX + ay*normalY + az*normalZ;\n    var v = new Utils.Vec3Constructor(normalX, normalY, normalZ);\n    v.w = offset;\n    return v;\n  }\n  */\n\n  static _buildPolygonsFromGeometry (geometry) {\n\n    const polygons = [];\n    var vertices = geometry.vertices;\n    const numVertices = geometry.indices ? geometry.vertices.length / 3 : vertices.length;   // Assumed Altern Geometry if got indices\n    //const faceVertexUvs = geometry.faceVertexUvs;\n\n    // Constructing the neighbor graph brute force is O(n²). To avoid that,\n    // create a map from vertices to the polygons that contain them, and use it\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\n    // is related to connectivity of the mesh.\n    const vertexPolygonMap = new Map(); // Map<vertexID, Set<polygonIndex>>\n    for (let i = 0; i < numVertices; i++) {\n      vertexPolygonMap.set(i, new Set());\n    }\n\n  // Convert the faces into a custom format that supports more than 3 vertices (but it really uses more than that? Seems like all trimeshes are used only)\n\n  if (geometry.indices) {  // Assumed Altern Geometry\n      for (i=0; i< geometry.indices.length; i+=3) {\n        polygons.push({\n        id: polygonId++,\n        vertexIds: [geometry.indices[i], geometry.indices[i+1], geometry.indices[i+2]],\n        centroid: this._alternCentroidFromVerticesIndices(geometry.vertices, geometry.indices[i], geometry.indices[i+1], geometry.indices[i+2]),\n        //normal: this._alternNormalFromVerticesIndices(geometry.vertices,geometry.indices[i], geometry.indices[i+1], geometry.indices[i+2]),  // appears to be unneeded\n        neighbours: []\n      });\n      vertexPolygonMap.get(geometry.indices[i]).add(polygons.length - 1);\n      vertexPolygonMap.get(geometry.indices[i+1]).add(polygons.length - 1);\n      vertexPolygonMap.get(geometry.indices[i+2]).add(polygons.length - 1);\n    }\n\n    var alternVertsConv = [];\n    for (i=0; i< geometry.vertices.length; i+=3) {\n      alternVertsConv.push( new Utils.Vec3Constructor(geometry.vertices[i], geometry.vertices[i+1], geometry.vertices[i+2]));\n    }\n    vertices = alternVertsConv;\n  }\n  else {  // Assumed THREEJS Geometry\n    geometry.faces.forEach((face) => {\n      polygons.push({\n        id: polygonId++,\n        vertexIds: [face.a, face.b, face.c],\n        centroid: face.centroid,\n        //normal: face.normal,\n        neighbours: []\n      });\n      vertexPolygonMap.get(face.a).add(polygons.length - 1);\n      vertexPolygonMap.get(face.b).add(polygons.length - 1);\n      vertexPolygonMap.get(face.c).add(polygons.length - 1);\n    });\n  }\n    const navigationMesh = {\n      polygons: polygons,\n      vertices: vertices,\n     // faceVertexUvs: faceVertexUvs\n    };\n\n    // Build a list of adjacent polygons\n    polygons.forEach((polygon) => {\n      this._buildPolygonNeighbours(polygon, navigationMesh, vertexPolygonMap);\n    });\n\n    return navigationMesh;\n  }\n\n  static _getSharedVerticesInOrder (a, b) {\n\n    const aList = a.vertexIds;\n    const bList = b.vertexIds;\n\n    const sharedVertices = new Set();\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVertices.add(vId);\n      }\n    });\n\n    if (sharedVertices.size < 2) return [];\n\n    if (sharedVertices.has(aList[0]) && sharedVertices.has(aList[aList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      aList.push(aList.shift());\n    }\n\n    if (sharedVertices.has(bList[0]) && sharedVertices.has(bList[bList.length - 1])) {\n      // Vertices on both edges are bad, so shift them once to the left\n      bList.push(bList.shift());\n    }\n\n    // Again!\n    const sharedVerticesOrdered = [];\n\n    aList.forEach((vId) => {\n      if (bList.includes(vId)) {\n        sharedVerticesOrdered.push(vId);\n      }\n    });\n\n    return sharedVerticesOrdered;\n  }\n}\n\nexport { Builder };\n","import { Utils } from './Utils';\n\nclass Channel {\n  constructor () {\n    this.portals = [];\n  }\n\n  push (p1, p2) {\n    if (p2 === undefined) p2 = p1;\n    this.portals.push({\n      left: p1,\n      right: p2\n    });\n  }\n\n  stringPull () {\n    const portals = this.portals;\n    const pts = [];\n    // Init scan state\n    let portalApex, portalLeft, portalRight;\n    let apexIndex = 0,\n      leftIndex = 0,\n      rightIndex = 0;\n\n    portalApex = portals[0].left;\n    portalLeft = portals[0].left;\n    portalRight = portals[0].right;\n\n    // Add start point.\n    pts.push(portalApex);\n\n    for (let i = 1; i < portals.length; i++) {\n      const left = portals[i].left;\n      const right = portals[i].right;\n\n      // Update right vertex.\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\n          // Tighten the funnel.\n          portalRight = right;\n          rightIndex = i;\n        } else {\n          // Right over left, insert left to path and restart scan from portal left point.\n          pts.push(portalLeft);\n          // Make current left the new apex.\n          portalApex = portalLeft;\n          apexIndex = leftIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n\n      // Update left vertex.\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\n          // Tighten the funnel.\n          portalLeft = left;\n          leftIndex = i;\n        } else {\n          // Left over right, insert right to path and restart scan from portal right point.\n          pts.push(portalRight);\n          // Make current right the new apex.\n          portalApex = portalRight;\n          apexIndex = rightIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n    }\n\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\n      // Append last point to path.\n      pts.push(portals[portals.length - 1].left);\n    }\n\n    this.path = pts;\n    return pts;\n  }\n}\n\nexport { Channel };\n","/* global THREE */\n\nimport { Utils } from './Utils';\nimport { AStar } from './AStar';\nimport { Builder } from './Builder';\nimport { Channel } from './Channel';\n\n/**\n * Defines an instance of the pathfinding module, with one or more zones.\n */\nclass Pathfinding {\n\tconstructor () {\n\t\tthis.zones = {};\n\t}\n\n\tstatic setVec3Constructor(cs) {\n\t\tUtils.Vec3Constructor= cs;\n\t}\n\n\t/**\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\n\t * @param  {THREE.BufferGeometry} geometry\n\t * @return {Zone}\n\t */\n\tstatic createZone (geometry) {\n\t\tif ( geometry.isGeometry ) {\n\t\t\t// Haven't actually implemented support for BufferGeometry yet, but Geometry is somewhat\n\t\t\t// not-recommended these days, so go ahead and start warning.\n\t\t\tconsole.warn('[three-pathfinding]: Use THREE.BufferGeometry, not THREE.Geometry, to create zone.');\n\t\t} else {\n\t\t\tgeometry = geometry.indices ? geometry : new THREE.Geometry().fromBufferGeometry(geometry);\n\t\t}\n\n\t\treturn Builder.buildZone(geometry);\n\t}\n\n\t/**\n\t * Sets data for the given zone.\n\t * @param {string} zoneID\n\t * @param {Zone} zone\n\t */\n\tsetZoneData (zoneID, zone) {\n\t\tthis.zones[zoneID] = zone;\n\t}\n\n\t/**\n\t * Returns closest node group ID for given position.\n\t * @param  {string} zoneID\n\t * @param  {THREE.Vector3} position\n\t * @return {number}\n\t */\n\tgetGroup (zoneID, position) {\n\t\tif (!this.zones[zoneID]) return null;\n\n\t\tlet closestNodeGroup = null;\n\t\tlet distance = Math.pow(50, 2);\n\n\t\tthis.zones[zoneID].groups.forEach((group, index) => {\n\t\t\tgroup.forEach((node) => {\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\n\t\t\t\tif (measuredDistance < distance) {\n\t\t\t\t\tclosestNodeGroup = index;\n\t\t\t\t\tdistance = measuredDistance;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn closestNodeGroup;\n\t}\n\n\t/**\n\t * Returns a random node within a given range of a given position.\n\t * @param  {string} zoneID\n\t * @param  {number} groupID\n\t * @param  {THREE.Vector3} nearPosition\n\t * @param  {number} nearRange\n\t * @return {Node}\n\t */\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\n\n\t\tif (!this.zones[zoneID]) return new Utils.Vec3Constructor();\n\n\t\tnearPosition = nearPosition || null;\n\t\tnearRange = nearRange || 0;\n\n\t\tconst candidates = [];\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\n\n\t\tpolygons.forEach((p) => {\n\t\t\tif (nearPosition && nearRange) {\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\n\t\t\t\t\tcandidates.push(p.centroid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcandidates.push(p.centroid);\n\t\t\t}\n\t\t});\n\n\t\treturn Utils.sample(candidates) || new Utils.Vec3Constructor();\n\t}\n\n\t/**\n\t * Returns the closest node to the target position.\n\t * @param  {THREE.Vector3} position\n\t * @param  {string}  zoneID\n\t * @param  {number}  groupID\n\t * @param  {boolean} checkPolygon\n\t * @return {Node}\n\t */\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tlet closestNode = null;\n\t\tlet closestDistance = Infinity;\n\n\t\tnodes.forEach((node) => {\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\n\t\t\tif (distance < closestDistance\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\n\t\t\t\tclosestNode = node;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closestNode;\n\t}\n\n\t/**\n\t * Returns a path between given start and end points. If a complete path\n\t * cannot be found, will return the nearest endpoint available.\n\t *\n\t * @param  {THREE.Vector3} startPosition Start position.\n\t * @param  {THREE.Vector3} targetPosition Destination.\n\t * @param  {string} zoneID ID of current zone.\n\t * @param  {number} groupID Current group ID.\n\t * @return {Array<THREE.Vector3>} Array of points defining the path.\n\t */\n\tfindPath (startPosition, targetPosition, zoneID, groupID) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\n\t\tconst closestNode = this.getClosestNode(startPosition, zoneID, groupID);\n\t\tconst farthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\n\n\t\t// If we can't find any node, just go straight to the target\n\t\tif (!closestNode || !farthestNode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\n\n\t\tconst getPortalFromTo = function (a, b) {\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\n\t\t\t\tif (a.neighbours[i] === b.id) {\n\t\t\t\t\treturn a.portals[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We have the corridor, now pull the rope.\n\t\tconst channel = new Channel();\n\t\tchannel.push(startPosition);\n\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\tconst polygon = paths[i];\n\t\t\tconst nextPolygon = paths[i + 1];\n\n\t\t\tif (nextPolygon) {\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\n\t\t\t\tchannel.push(\n\t\t\t\t\tvertices[portals[0]],\n\t\t\t\t\tvertices[portals[1]]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tchannel.push(targetPosition);\n\t\tchannel.stringPull();\n\n\t\t// Return the path, omitting first position (which is already known).\n\t\tconst path = channel.path.map((c) => new Utils.Vec3Constructor(c.x, c.y, c.z));\n\t\tpath.shift();\n\t\treturn path;\n\t}\n}\n\n/**\n * Clamps a step along the navmesh, given start and desired endpoint. May be\n * used to constrain first-person / WASD controls.\n *\n * @param  {THREE.Vector3} start\n * @param  {THREE.Vector3} end Desired endpoint.\n * @param  {Node} node\n * @param  {string} zoneID\n * @param  {number} groupID\n * @param  {THREE.Vector3} endTarget Updated endpoint.\n * @return {Node} Updated node.\n */\n/*\nPathfinding.prototype.clampStep = (function () {\n\tif (!window.THREE) {\n\n\t\talert('clampStep not supported without THREEJS');\n\t\treturn;\n\t}\n\tconst point = new THREE.Vector3();\n\tconst plane = new THREE.Plane();\n\tconst triangle = new THREE.Triangle();\n\n\tlet closestNode;\n\tlet closestPoint = new THREE.Vector3();\n\tlet closestDistance;\n\n\treturn function (start, end, node, zoneID, groupID, endTarget) {\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\n\t\tconst nodeQueue = [node];\n\t\tconst nodeDepth = {};\n\t\tnodeDepth[node.id] = 0;\n\n\t\tclosestNode = undefined;\n\t\tclosestPoint.set(0, 0, 0);\n\t\tclosestDistance = Infinity;\n\n\t\t// Project the step along the current node.\n\t\tplane.setFromCoplanarPoints(\n\t\t\tvertices[node.vertexIds[0]],\n\t\t\tvertices[node.vertexIds[1]],\n\t\t\tvertices[node.vertexIds[2]]\n\t\t);\n\t\tplane.projectPoint(end, point);\n\t\tend.copy(point);\n\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\n\n\t\t\ttriangle.set(\n\t\t\t\tvertices[currentNode.vertexIds[0]],\n\t\t\t\tvertices[currentNode.vertexIds[1]],\n\t\t\t\tvertices[currentNode.vertexIds[2]]\n\t\t\t);\n\n\t\t\ttriangle.closestPointToPoint(end, point);\n\n\t\t\tif (point.distanceToSquared(end) < closestDistance) {\n\t\t\t\tclosestNode = currentNode;\n\t\t\t\tclosestPoint.copy(point);\n\t\t\t\tclosestDistance = point.distanceToSquared(end);\n\t\t\t}\n\n\t\t\tconst depth = nodeDepth[currentNode];\n\t\t\tif (depth > 2) continue;\n\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\n\n\t\t\t\tnodeQueue.push(neighbour);\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\n\t\t\t}\n\t\t}\n\n\t\tendTarget.copy(closestPoint);\n\t\treturn closestNode;\n\t};\n}());\n*/\n\n/**\n * Defines a zone of interconnected groups on a navigation mesh.\n *\n * @type {Object}\n * @property {Array<Group>} groups\n * @property {Array<THREE.Vector3} vertices\n */\nconst Zone = {}; // jshint ignore:line\n\n/**\n * Defines a group within a navigation mesh.\n *\n * @type {Object}\n */\nconst Group = {}; // jshint ignore:line\n\n/**\n * Defines a node (or polygon) within a group.\n *\n * @type {Object}\n * @property {number} id\n * @property {Array<number>} neighbours IDs of neighboring nodes.\n * @property {Array<number} vertexIds\n * @property {THREE.Vector3} centroid\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\n * @property {boolean} closed\n * @property {number} cost\n */\nconst Node = {}; // jshint ignore:line\n\nexport { Pathfinding };\n"],"names":["Utils","computeCentroids","geometry","f","fl","face","faces","length","centroid","Vec3Constructor","add","vertices","a","b","c","divideScalar","roundNumber","value","decimals","Number","toFixed","sample","list","Math","floor","random","mergeVertexIds","aList","bList","sharedVertices","forEach","vID","indexOf","push","includes","shift","vId","clockwiseMostSharedVertex","counterClockwiseMostSharedVertex","cList","slice","temp","Error","pop","concat","setPolygonCentroid","polygon","navigationMesh","sum","vertexIds","copy","cleanPolygon","newVertexIds","i","nextVertexId","previousVertexId","previousVertex","vertex","clone","sub","angle","angleTo","PI","goodNeighbours","neighbours","neighbour","isConvex","convex","results","nextVertex","r","cross","y","distanceToSquared","dx","x","dy","dz","z","isPointInPoly","poly","pt","l","j","isVectorInPolygon","vector","lowestPoint","highestPoint","polygonVertices","min","max","this","triarea2","vequal","window","THREE","Vector3","BinaryHeap","scoreFunction","content","element","sinkDown","result","end","bubbleUp","remove","node","const","size","rescoreElement","n","parentN","parent","elemScore","child2N","child1N","swap","child1Score","AStar","init","graph","let","g","h","cost","visited","closed","cleanUp","heap","search","start","openHeap","currentNode","curr","ret","reverse","il","gScore","neighbourCosts","beenVisited","heuristic","pos1","pos2","deltaX","deltaY","deltaZ","sqrt","e","polygonId","Builder","buildZone","navMesh","_buildNavigationMesh","zone","v","groups","_buildPolygonGroups","findPolygonIndex","group","p","newGroup","map","portals","_getSharedVerticesInOrder","id","mergeVertices","_buildPolygonsFromGeometry","polygonGroups","groupCount","spreadGroupId","undefined","polygons","_buildPolygonNeighbours","vertexPolygonMap","neighbors","Set","groupA","get","groupB","groupC","candidate","has","Array","from","_getCostsOfNeighboursFromCentroid","_alternCentroidFromVerticesIndices","ay","az","bz","numVertices","indices","Map","set","alternVertsConv","sharedVerticesOrdered","Channel","p1","p2","stringPull","portalApex","portalLeft","portalRight","pts","apexIndex","leftIndex","rightIndex","left","right","path","Pathfinding","zones","setVec3Constructor","cs","createZone","isGeometry","console","warn","Geometry","fromBufferGeometry","setZoneData","zoneID","getGroup","position","closestNodeGroup","distance","pow","index","measuredDistance","getRandomNode","groupID","nearPosition","nearRange","candidates","getClosestNode","checkPolygon","closestNode","closestDistance","Infinity","findPath","startPosition","targetPosition","nodes","farthestNode","paths","getPortalFromTo","channel","nextPolygon"],"mappings":"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"}